

int Cell_Power = 12; int Sol_In = 7; int Sol_Out = 8; int Reverse_Relay1 = 11; int Reverse_Relay2 = 10; int Pump = 9; int ledPin = 13; unsigned long previousMillis = 0; unsigned long startTime = 0; const long interval1 = 1000; // 1초 const long interval2 = 30000; // 30초 const long interval3 = 60000; // 1분 const long interval4 = 27000; // 27초 const long interval5 = 2000; // 2초 const long interval6 = 500; // 0.5초 const long interval7 = 56000; // 56초 int state = 0; // 현재 작업 상태를 나타내는 변수 int cycle = 0; void setup() { pinMode(Cell_Power, OUTPUT); digitalWrite(Cell_Power, HIGH); pinMode(Sol_In, OUTPUT); digitalWrite(Sol_In, HIGH); pinMode(Sol_Out, OUTPUT); digitalWrite(Sol_Out, HIGH); pinMode(Reverse_Relay1, OUTPUT); digitalWrite(Reverse_Relay1, HIGH); pinMode(Reverse_Relay2, OUTPUT); digitalWrite(Reverse_Relay2, HIGH); pinMode(Pump, OUTPUT); digitalWrite(Pump, HIGH); pinMode(ledPin, OUTPUT); digitalWrite(ledPin, LOW); Serial.begin(9600); // 시리얼 통신 시작 startTime = millis(); // 프로그램 시작 시간 기록 } void loop() { unsigned long currentMillis = millis(); // 각 작업 상태에 따라 일정 시간이 지나면 다음 작업으로 넘어갑니다. switch(state) { case 0: digitalWrite(ledPin, HIGH); digitalWrite(Cell_Power, LOW); digitalWrite(Sol_Out, LOW); if (currentMillis - previousMillis >= interval1) { previousMillis = currentMillis; state = 1; } break; case 1: digitalWrite(Sol_In, LOW); digitalWrite(Pump, LOW); if (currentMillis - previousMillis >= interval2) { previousMillis = currentMillis; state = 2; } break; case 2: digitalWrite(Pump, HIGH); digitalWrite(Sol_In, HIGH); if (currentMillis - previousMillis >= interval1) { previousMillis = currentMillis; state = 3; } break; case 3: digitalWrite(Sol_Out, HIGH); if (currentMillis - previousMillis >= interval3) { previousMillis = currentMillis; state = 4; } break; case 4: digitalWrite(Sol_In, LOW); if (currentMillis - previousMillis >= interval1) { previousMillis = currentMillis; state = 5; } break; case 5: digitalWrite(Sol_In, HIGH); digitalWrite(Cell_Power, HIGH); digitalWrite(ledPin, LOW); if (currentMillis - previousMillis >= interval4) { previousMillis = currentMillis; state = 0; } break; case 6: digitalWrite(ledPin, LOW); digitalWrite(Pump, HIGH); digitalWrite(Sol_In, HIGH); digitalWrite(Sol_Out, HIGH); digitalWrite(Cell_Power, HIGH); if (currentMillis - previousMillis >= interval5) { previousMillis = currentMillis; state = 7; } break; case 7: digitalWrite(Sol_Out, LOW); if (currentMillis - previousMillis >= interval1) { previousMillis = currentMillis; state = 8; } break; case 8: digitalWrite(Sol_In, LOW); digitalWrite(Pump, LOW); digitalWrite(Cell_Power, LOW); if (currentMillis - previousMillis >= interval5) { previousMillis = currentMillis; state = 9; } break; case 9: digitalWrite(ledPin, LOW); digitalWrite(Pump, HIGH); digitalWrite(Sol_In, HIGH); if (currentMillis - previousMillis >= interval1) { previousMillis = currentMillis; state = 10; } break; case 10: digitalWrite(Sol_Out, HIGH); digitalWrite(Cell_Power, LOW); digitalWrite(Reverse_Relay1, LOW); digitalWrite(Reverse_Relay2, LOW); if (currentMillis - previousMillis >= interval6) { previousMillis = currentMillis; state = 11; } break; case 11: digitalWrite(ledPin, HIGH); digitalWrite(Cell_Power, LOW); if (currentMillis - previousMillis >= interval7) { previousMillis = currentMillis; state = 12; } break; case 12: digitalWrite(Cell_Power, HIGH); if (currentMillis - previousMillis >= interval6) { previousMillis = currentMillis; state = 13; } break; case 13: digitalWrite(ledPin, LOW); digitalWrite(Reverse_Relay1, HIGH); digitalWrite(Reverse_Relay2, HIGH); if (currentMillis - previousMillis >= interval1) { previousMillis = currentMillis; state = 14; } break; case 14: digitalWrite(ledPin, HIGH); digitalWrite(Cell_Power, LOW); if (currentMillis - previousMillis >= interval7) { previousMillis = currentMillis; state = 15; } break; case 15: digitalWrite(ledPin, LOW); digitalWrite(Sol_In, LOW); if (currentMillis - previousMillis >= interval1) { previousMillis = currentMillis; state = 16; } break; case 16: digitalWrite(Sol_In, HIGH); digitalWrite(Cell_Power, HIGH); if (currentMillis - previousMillis >= interval1) { previousMillis = currentMillis; state = 0; } break; } // 프로그램 종료 조건 추가 if (currentMillis > 26000000) { // 60초가 지나면 프로그램 종료 while(1); // 무한 루프에 빠지면서 프로그램을 종료 } } 코드 설명해줘



